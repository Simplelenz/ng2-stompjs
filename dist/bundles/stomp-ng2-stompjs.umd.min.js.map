{"version":3,"sources":["node_modules/tslib/tslib.es6.js","ng://@stomp/ng2-stompjs/src/stomp-r.service.ts","ng://@stomp/ng2-stompjs/src/stomp.config.ts","ng://@stomp/ng2-stompjs/src/stomp.service.ts","ng://@stomp/ng2-stompjs/src/stomp-rpc.service.ts"],"names":["extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","hasOwnProperty","args","console","log","Date","frame","_this","debug","_serverHeadersBehaviourSubject","next","headers","state","StompState","CONNECTED","error","errorSubject","body","client","connected","CLOSED","this","BehaviorSubject","connectObservable","pipe","filter","currentState","subscribe","sendQueuedMessages","serverHeadersObservable","Subject","defineProperty","StompRService","prototype","value","_config","initStompClient","disconnect","Stomp.client","url","Stomp.over","heartbeat","incoming","heartbeat_in","outgoing","heartbeat_out","reconnect_delay","setupOnReceive","setupReceipts","initAndConnect","connect","on_connect","on_error","TRYING","DISCONNECTING","getValue","publish","queueName","message","send","queuedMessages","push","queuedMessages_1","__values","o","m","Symbol","iterator","i","call","length","done","tslib_1.__values","queuedMessages_1_1","queuedMessage","Observable","create","messages","stompSubscription","stompConnectedSubscription","unsubscribe","share","defaultMessagesObservable","onreceive","receiptsObservable","onreceipt","waitForReceipt","receiptId","callback","first","Injectable","config","_super","__extends","__","constructor","tslib_1.__extends","StompConfig","StompRPCService","stompService","messagesObservable","rpc","serviceEndPoint","payload","stream","rpcObserver","defaultMessagesSubscription","correlationId","UUID","replyQueue"],"mappings":"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","sourcesContent":["/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)\r\n            t[p[i]] = s[p[i]];\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n","import { first, filter, share } from 'rxjs/operators';\nimport { Injectable } from '@angular/core';\nimport { BehaviorSubject ,  Observable ,  Observer ,  Subject ,  Subscription } from 'rxjs';\n\nimport { StompConfig } from './stomp.config';\n\nimport * as Stomp from '@stomp/stompjs';\nimport { Frame, StompSubscription } from '@stomp/stompjs';\nimport { StompHeaders } from './stomp-headers';\nimport { StompState } from './stomp-state';\n\n/**\n * Angular2 STOMP Raw Service using @stomp/stomp.js\n *\n * You will only need the public properties and\n * methods listed unless you are an advanced user. This service handles subscribing to a\n * message queue using the stomp.js library, and returns\n * values via the ES6 Observable specification for\n * asynchronous value streaming by wiring the STOMP\n * messages into an observable.\n *\n * If you will like to pass the configuration as a dependency,\n * please use StompService class.\n */\n@Injectable()\nexport class StompRService {\n  /**\n   * State of the STOMPService\n   *\n   * It is a BehaviorSubject and will emit current status immediately. This will typically get\n   * used to show current status to the end user.\n   */\n  public state: BehaviorSubject<StompState>;\n\n  /**\n   * Will trigger when connection is established. Use this to carry out initialization.\n   * It will trigger every time a (re)connection occurs. If it is already connected\n   * it will trigger immediately. You can safely ignore the value, as it will always be\n   * StompState.CONNECTED\n   */\n  public connectObservable: Observable<StompState>;\n\n  /**\n   * Provides headers from most recent connection to the server as return by the CONNECTED\n   * frame.\n   * If the STOMP connection has already been established it will trigger immediately.\n   * It will additionally trigger in event of reconnection, the value will be set of headers from\n   * the recent server response.\n   */\n  public serverHeadersObservable: Observable<StompHeaders>;\n\n  private _serverHeadersBehaviourSubject: BehaviorSubject<null | StompHeaders>;\n\n  /**\n   * Will emit all messages to the default queue (any message that are not handled by a subscription)\n   */\n  public defaultMessagesObservable: Subject<Stomp.Message>;\n\n  /**\n   * Will emit all receipts\n   */\n  public receiptsObservable: Subject<Stomp.Frame>;\n\n  /**\n   * Will trigger when an error occurs. This Subject can be used to handle errors from\n   * the stomp broker.\n   */\n  public errorSubject: Subject<string | Stomp.Message>;\n\n  /**\n   * Internal array to hold locally queued messages when STOMP broker is not connected.\n   */\n  protected queuedMessages: { queueName: string, message: string, headers: StompHeaders }[] = [];\n\n  /**\n   * Configuration\n   */\n  private _config: StompConfig;\n\n  /**\n   * STOMP Client from @stomp/stomp.js\n   */\n  protected client: Stomp.Client;\n\n  /**\n   * Constructor\n   *\n   * See README and samples for configuration examples\n   */\n  public constructor() {\n    this.state = new BehaviorSubject<StompState>(StompState.CLOSED);\n\n    this.connectObservable = this.state.pipe(\n      filter((currentState: StompState) => {\n        return currentState === StompState.CONNECTED;\n      })\n    );\n\n    // Setup sending queuedMessages\n    this.connectObservable.subscribe(() => {\n      this.sendQueuedMessages();\n    });\n\n    this._serverHeadersBehaviourSubject = new BehaviorSubject<null | StompHeaders>(null);\n\n    this.serverHeadersObservable = this._serverHeadersBehaviourSubject.pipe(\n      filter((headers: null | StompHeaders) => {\n        return headers !== null;\n      })\n    );\n\n    this.errorSubject = new Subject();\n  }\n\n  /** Set configuration */\n  set config(value: StompConfig) {\n    this._config = value;\n  }\n\n  /** It will initialize STOMP Client. */\n  protected initStompClient(): void {\n    // disconnect if connected\n    this.disconnect();\n\n    // url takes precedence over socketFn\n    if (typeof(this._config.url) === 'string') {\n      this.client = Stomp.client(this._config.url);\n    } else {\n      this.client = Stomp.over(this._config.url);\n    }\n\n    // Configure client heart-beating\n    this.client.heartbeat.incoming = this._config.heartbeat_in;\n    this.client.heartbeat.outgoing = this._config.heartbeat_out;\n\n    // Auto reconnect\n    this.client.reconnect_delay = this._config.reconnect_delay;\n\n    if (!this._config.debug) {\n      this.debug = function () {\n      };\n    }\n    // Set function to debug print messages\n    this.client.debug = this.debug;\n\n    // Default messages\n    this.setupOnReceive();\n\n    // Receipts\n    this.setupReceipts();\n  }\n\n\n  /**\n   * It will connect to the STOMP broker.\n   */\n  public initAndConnect(): void {\n    this.initStompClient();\n\n    if (!this._config.headers) {\n      this._config.headers = {};\n    }\n\n    // Attempt connection, passing in a callback\n    this.client.connect(\n      this._config.headers,\n      this.on_connect,\n      this.on_error\n    );\n\n    this.debug('Connecting...');\n    this.state.next(StompState.TRYING);\n  }\n\n\n  /**\n   * It will disconnect from the STOMP broker.\n   */\n  public disconnect(): void {\n\n    // Disconnect if connected. Callback will set CLOSED state\n    if (this.client) {\n      if (!this.client.connected) {\n        // Nothing to do\n        this.state.next(StompState.CLOSED);\n        return;\n      }\n\n      // Notify observers that we are disconnecting!\n      this.state.next(StompState.DISCONNECTING);\n\n      this.client.disconnect(\n        () => this.state.next(StompState.CLOSED)\n      );\n    }\n  }\n\n  /**\n   * It will return `true` if STOMP broker is connected and `false` otherwise.\n   */\n  public connected(): boolean {\n    return this.state.getValue() === StompState.CONNECTED;\n  }\n\n  /**\n   * It will send a message to a named destination. The message must be `string`.\n   *\n   * The message will get locally queued if the STOMP broker is not connected. It will attempt to\n   * publish queued messages as soon as the broker gets connected.\n   *\n   * @param queueName\n   * @param message\n   * @param headers\n   */\n  public publish(queueName: string, message: string, headers: StompHeaders = {}): void {\n    if (this.connected()) {\n      this.client.send(queueName, headers, message);\n    } else {\n      this.debug(`Not connected, queueing ${message}`);\n      this.queuedMessages.push({queueName: <string>queueName, message: <string>message, headers: headers});\n    }\n  }\n\n  /** It will send queued messages. */\n  protected sendQueuedMessages(): void {\n    const queuedMessages = this.queuedMessages;\n    this.queuedMessages = [];\n\n    this.debug(`Will try sending queued messages ${queuedMessages}`);\n\n    for (const queuedMessage of queuedMessages) {\n      this.debug(`Attempting to send ${queuedMessage}`);\n      this.publish(queuedMessage.queueName, queuedMessage.message, queuedMessage.headers);\n    }\n  }\n\n  /**\n   * It will subscribe to server message queues\n   *\n   * This method can be safely called even if the STOMP broker is not connected.\n   * If the underlying STOMP connection drops and reconnects, it will resubscribe automatically.\n   *\n   * If a header field 'ack' is not explicitly passed, 'ack' will be set to 'auto'. If you\n   * do not understand what it means, please leave it as is.\n   *\n   * Note that when working with temporary queues where the subscription request\n   * creates the\n   * underlying queue, mssages might be missed during reconnect. This issue is not specific\n   * to this library but the way STOMP brokers are designed to work.\n   *\n   * @param queueName\n   * @param headers\n   */\n  public subscribe(queueName: string, headers: StompHeaders = {}): Observable<Stomp.Message> {\n\n    /* Well the logic is complicated but works beautifully. RxJS is indeed wonderful.\n     *\n     * We need to activate the underlying subscription immediately if Stomp is connected. If not it should\n     * subscribe when it gets next connected. Further it should re establish the subscription whenever Stomp\n     * successfully reconnects.\n     *\n     * Actual implementation is simple, we filter the BehaviourSubject 'state' so that we can trigger whenever Stomp is\n     * connected. Since 'state' is a BehaviourSubject, if Stomp is already connected, it will immediately trigger.\n     *\n     * The observable that we return to caller remains same across all reconnects, so no special handling needed at\n     * the message subscriber.\n     */\n    this.debug(`Request to subscribe ${queueName}`);\n\n    // By default auto acknowledgement of messages\n    if (!headers['ack']) {\n      headers['ack'] = 'auto';\n    }\n\n    const coldObservable = Observable.create(\n      (messages: Observer<Stomp.Message>) => {\n        /*\n         * These variables will be used as part of the closure and work their magic during unsubscribe\n         */\n        let stompSubscription: StompSubscription;\n\n        let stompConnectedSubscription: Subscription;\n\n        stompConnectedSubscription = this.connectObservable\n          .subscribe(() => {\n            this.debug(`Will subscribe to ${queueName}`);\n            stompSubscription = this.client.subscribe(queueName, (message: Stomp.Message) => {\n                messages.next(message);\n              },\n              headers);\n          });\n\n        return () => { /* cleanup function, will be called when no subscribers are left */\n          this.debug(`Stop watching connection state (for ${queueName})`);\n          stompConnectedSubscription.unsubscribe();\n\n          if (this.state.getValue() === StompState.CONNECTED) {\n            this.debug(`Will unsubscribe from ${queueName} at Stomp`);\n            stompSubscription.unsubscribe();\n          } else {\n            this.debug(`Stomp not connected, no need to unsubscribe from ${queueName} at Stomp`);\n          }\n        };\n      });\n\n    /**\n     * Important - convert it to hot Observable - otherwise, if the user code subscribes\n     * to this observable twice, it will subscribe twice to Stomp broker. (This was happening in the current example).\n     * A long but good explanatory article at https://medium.com/@benlesh/hot-vs-cold-observables-f8094ed53339\n     */\n    return coldObservable.pipe(share());\n  }\n\n  /**\n   * It will handle messages received in the default queue. Messages that would not be handled otherwise\n   * get delivered to the default queue.\n   */\n  protected setupOnReceive(): void {\n    this.defaultMessagesObservable = new Subject();\n\n    this.client.onreceive = (message: Stomp.Message) => {\n      this.defaultMessagesObservable.next(message);\n    };\n  }\n\n  /**\n   * It will emit all receipts.\n   */\n  protected setupReceipts(): void {\n    this.receiptsObservable = new Subject();\n\n    this.client.onreceipt = (frame: Stomp.Frame) => {\n      this.receiptsObservable.next(frame);\n    };\n  }\n\n  /**\n   * Wait for receipt, this indicates that server has carried out the related operation\n   */\n  public waitForReceipt(receiptId: string, callback: (frame: Stomp.Frame) => void): void {\n    this.receiptsObservable.pipe(\n      filter((frame: Stomp.Frame) => {\n        return frame.headers['receipt-id'] === receiptId;\n      }),\n      first()\n    ).subscribe((frame: Stomp.Frame) => {\n      callback(frame);\n    });\n  }\n\n  /**\n   * Callback Functions\n   *\n   * Note the method signature: () => preserves lexical scope\n   * if we need to use this.x inside the function\n   */\n  protected debug = (args: any): void => {\n    console.log(new Date(), args);\n  }\n\n  /** Callback run on successfully connecting to server */\n  protected on_connect = (frame: Frame) => {\n\n    this.debug('Connected');\n\n    this._serverHeadersBehaviourSubject.next(frame.headers);\n\n    // Indicate our connected state to observers\n    this.state.next(StompState.CONNECTED);\n  }\n\n  /** Handle errors from stomp.js */\n  protected on_error = (error: string | Stomp.Message) => {\n\n    // Trigger the error subject\n    this.errorSubject.next(error);\n\n    if (typeof error === 'object') {\n      error = (<Stomp.Message>error).body;\n    }\n\n    this.debug(`Error: ${error}`);\n\n    // Check for dropped connection and try reconnecting\n    if (!this.client.connected) {\n      // Reset state indicator\n      this.state.next(StompState.CLOSED);\n    }\n  }\n}\n","import { StompHeaders } from './stomp-headers';\nimport { Injectable } from '@angular/core';\n/**\n * Represents a configuration object for the\n * STOMPService to connect to.\n */\n\n@Injectable()\nexport class StompConfig {\n  /**\n   * Server URL to connect to. Please refer to your STOMP broker documentation for details.\n   *\n   * Example: ws://127.0.0.1:15674/ws (for a RabbitMQ default setup running on localhost)\n   *\n   * Alternatively this parameter can be a function that returns an object similar to WebSocket\n   * (typically SockJS instance).\n   *\n   * Example:\n   *\n   * () => {\n   *   return new SockJS('http://127.0.0.1:15674/stomp');\n   * }\n   */\n  url: string | (() => any);\n\n  /**\n   * Headers\n   * Typical keys: login: string, passcode: string.\n   * host:string will neeed to be passed for virtual hosts in RabbitMQ\n   */\n  headers: StompHeaders;\n\n  /** How often to incoming heartbeat?\n   * Interval in milliseconds, set to 0 to disable\n   *\n   * Typical value 0 - disabled\n   */\n  heartbeat_in: number;\n\n  /**\n   * How often to outgoing heartbeat?\n   * Interval in milliseconds, set to 0 to disable\n   *\n   * Typical value 20000 - every 20 seconds\n   */\n  heartbeat_out: number;\n\n  /**\n   * Wait in milliseconds before attempting auto reconnect\n   * Set to 0 to disable\n   *\n   * Typical value 5000 (5 seconds)\n   */\n  reconnect_delay: number;\n\n  /** Enable client debugging? */\n  debug: boolean;\n}\n","import { Injectable } from '@angular/core';\n\nimport { StompConfig } from './stomp.config';\n\nimport { StompRService } from './stomp-r.service';\n\n/**\n * Angular2 STOMP Service using @stomp/stomp.js\n *\n * @description This service handles subscribing to a\n * message queue using the stomp.js library, and returns\n * values via the ES6 Observable specification for\n * asynchronous value streaming by wiring the STOMP\n * messages into an observable.\n *\n * If you want to manually configure and initialize the service\n * please use StompRService\n */\n@Injectable()\nexport class StompService extends StompRService {\n\n  /**\n   * Constructor\n   *\n   * See README and samples for configuration examples\n   */\n  public constructor(config: StompConfig) {\n    super();\n\n    this.config = config;\n    this.initAndConnect();\n  }\n}\n","import { Injectable } from '@angular/core';\nimport { Message, StompHeaders } from '@stomp/stompjs';\nimport { UUID } from 'angular2-uuid';\nimport { Observable, Observer, Subject, Subscription } from \"rxjs\";\nimport { filter, first } from \"rxjs/operators\";\nimport { StompRService } from \"./stomp-r.service\";\n\n@Injectable()\nexport class StompRPCService {\n  protected replyQueue = '/temp-queue/rpc-replies';\n\n  protected messagesObservable: Observable<Message>;\n\n  constructor(private stompService: StompRService) {\n    this.messagesObservable = this.stompService.defaultMessagesObservable;\n  }\n\n  public rpc(serviceEndPoint: string, payload: string, headers?: StompHeaders): Observable<Message> {\n    // We know there will be only one message in reply\n    return this.stream(serviceEndPoint, payload, headers).pipe(first());\n  }\n\n  private stream(serviceEndPoint: string, payload: string, headers: StompHeaders = {}) {\n    return Observable.create(\n      (rpcObserver: Observer<Message>) => {\n        let defaultMessagesSubscription: Subscription;\n\n        const correlationId = UUID.UUID();\n\n        defaultMessagesSubscription = this.messagesObservable.pipe(filter((message: Message) => {\n          return message.headers['correlation-id'] === correlationId;\n        })).subscribe((message: Message) => {\n          rpcObserver.next(message);\n        });\n\n        // send an RPC request\n        headers['reply-to'] = this.replyQueue;\n        headers['correlation-id'] = correlationId;\n\n        this.stompService.publish(serviceEndPoint, payload, headers);\n\n        return () => { // Cleanup\n          defaultMessagesSubscription.unsubscribe();\n        };\n      }\n    );\n  }\n}\n"]}