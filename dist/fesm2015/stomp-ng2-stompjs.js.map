{"version":3,"file":"stomp-ng2-stompjs.js.map","sources":["ng://@stomp/ng2-stompjs/src/stomp-r.service.ts","ng://@stomp/ng2-stompjs/src/stomp.config.ts","ng://@stomp/ng2-stompjs/src/stomp.service.ts","ng://@stomp/ng2-stompjs/src/stomp-rpc.service.ts","ng://@stomp/ng2-stompjs/src/stomp-rpc.config.ts"],"sourcesContent":["import {Injectable} from '@angular/core';\n\nimport {RxStomp, RxStompConfig, RxStompState} from \"@stomp/rx-stomp\";\n\nimport {publishParams, Client, Message, Frame} from \"@stomp/stompjs\";\n\nimport {BehaviorSubject, Observable, Subject} from \"rxjs\";\nimport {map} from \"rxjs/operators\";\n\nimport {StompState} from \"./stomp-state\";\nimport { StompHeaders } from './stomp-headers';\nimport {StompConfig} from \"./stomp.config\";\n\n/**\n * Angular2 STOMP Raw Service using @stomp/stomp.js\n *\n * You will only need the public properties and\n * methods listed unless you are an advanced user. This service handles subscribing to a\n * message queue using the stomp.js library, and returns\n * values via the ES6 Observable specification for\n * asynchronous value streaming by wiring the STOMP\n * messages into an observable.\n *\n * If you will like to pass the configuration as a dependency,\n * please use StompService class.\n */\n@Injectable()\nexport class StompRService extends RxStomp {\n  /**\n   * State of the STOMPService\n   *\n   * It is a BehaviorSubject and will emit current status immediately. This will typically get\n   * used to show current status to the end user.\n   */\n  public state: BehaviorSubject<StompState>;\n\n  private static _mapStompState(st: RxStompState): StompState {\n    if (st === RxStompState.CONNECTING) {\n      return StompState.TRYING;\n    }\n    if (st === RxStompState.OPEN) {\n      return StompState.CONNECTED;\n    }\n    if (st === RxStompState.CLOSING) {\n      return StompState.DISCONNECTING;\n    }\n    if (st === RxStompState.CLOSED) {\n      return StompState.CLOSED;\n    }\n  }\n\n  /**\n   * Will trigger when connection is established. Use this to carry out initialization.\n   * It will trigger every time a (re)connection occurs. If it is already connected\n   * it will trigger immediately. You can safely ignore the value, as it will always be\n   * StompState.CONNECTED\n   */\n  get connectObservable(): Observable<StompState> {\n    return this.connected$.pipe(map((st: RxStompState): StompState => {\n      return StompRService._mapStompState(st);\n    }));\n  }\n\n  /**\n   * Provides headers from most recent connection to the server as return by the CONNECTED\n   * frame.\n   * If the STOMP connection has already been established it will trigger immediately.\n   * It will additionally trigger in event of reconnection, the value will be set of headers from\n   * the recent server response.\n   */\n  get serverHeadersObservable(): Observable<StompHeaders> {\n    return this.serverHeaders$;\n  }\n\n  /**\n   * Will emit all messages to the default queue (any message that are not handled by a subscription)\n   */\n  get defaultMessagesObservable(): Subject<Message> {\n    return this.unhandledMessage$;\n  }\n\n  /**\n   * Will emit all receipts\n   */\n  get receiptsObservable(): Subject<Frame> {\n    return this.unhandledReceipts$;\n  }\n\n  /**\n   * Will trigger when an error occurs. This Subject can be used to handle errors from\n   * the stomp broker.\n   */\n  get errorSubject(): Subject<string | Frame> {\n    return this.stompErrors$;\n  }\n\n  /** Set configuration */\n  set config(config: StompConfig) {\n    const rxStompConfig: RxStompConfig = { };\n\n    if (typeof(config.url) === 'string') {\n      rxStompConfig.brokerURL = config.url;\n    } else {\n      rxStompConfig.webSocketFactory = config.url;\n    }\n\n    // Configure client heart-beating\n    rxStompConfig.heartbeatIncoming = config.heartbeat_in;\n    rxStompConfig.heartbeatOutgoing = config.heartbeat_out;\n\n    // Auto reconnect\n    rxStompConfig.reconnectDelay = config.reconnect_delay;\n\n    if (config.debug) {\n      rxStompConfig.debug = (str: string): void => {\n        console.log(new Date(), str);\n      }\n    }\n\n    rxStompConfig.connectHeaders = config.headers;\n\n    this.configure(rxStompConfig);\n  }\n  /**\n   * It will connect to the STOMP broker.\n   */\n  public initAndConnect(): void {\n    // disconnect if connected\n    this.deactivate();\n\n    // Attempt connection, passing in a callback\n    this.activate();\n  }\n\n  /**\n   * It will disconnect from the STOMP broker.\n   */\n  public disconnect(): void {\n    this.deactivate();\n  }\n\n  /**\n   * It will send a message to a named destination. The message must be `string`.\n   *\n   * The message will get locally queued if the STOMP broker is not connected. It will attempt to\n   * publish queued messages as soon as the broker gets connected.\n   *\n   * @param queueName\n   * @param message\n   * @param headers\n   */\n  public publish(queueName: string|publishParams, message?: string, headers: StompHeaders = {}): void {\n    if (typeof queueName === 'string') {\n      super.publish({destination: queueName as string, body: message, headers});\n    } else {\n      const pubParams: publishParams = queueName;\n      super.publish(pubParams);\n    }\n  }\n\n  /**\n   * It will subscribe to server message queues\n   *\n   * This method can be safely called even if the STOMP broker is not connected.\n   * If the underlying STOMP connection drops and reconnects, it will resubscribe automatically.\n   *\n   * If a header field 'ack' is not explicitly passed, 'ack' will be set to 'auto'. If you\n   * do not understand what it means, please leave it as is.\n   *\n   * Note that when working with temporary queues where the subscription request\n   * creates the\n   * underlying queue, mssages might be missed during reconnect. This issue is not specific\n   * to this library but the way STOMP brokers are designed to work.\n   *\n   * @param queueName\n   * @param headers\n   */\n  public subscribe(queueName: string, headers: StompHeaders = {}): Observable<Message> {\n    return this.watch(queueName, headers);\n  }\n\n  get client(): Client {\n    return this._stompClient;\n  }\n\n  public constructor() {\n    super();\n\n    this.state = new BehaviorSubject<StompState>(StompState.CLOSED);\n\n    this.connectionState$.subscribe((st: RxStompState) => {\n      this.state.next(StompRService._mapStompState(st));\n    });\n  }\n}\n","import { Injectable } from '@angular/core';\nimport { StompHeaders } from \"@stomp/stompjs\";\n/**\n * Represents a configuration object for the\n * STOMPService to connect to.\n */\n\n@Injectable()\nexport class StompConfig {\n  /**\n   * Server URL to connect to. Please refer to your STOMP broker documentation for details.\n   *\n   * Example: ws://127.0.0.1:15674/ws (for a RabbitMQ default setup running on localhost)\n   *\n   * Alternatively this parameter can be a function that returns an object similar to WebSocket\n   * (typically SockJS instance).\n   *\n   * Example:\n   *\n   * () => {\n   *   return new SockJS('http://127.0.0.1:15674/stomp');\n   * }\n   */\n  url: string | (() => any);\n\n  /**\n   * Headers\n   * Typical keys: login: string, passcode: string.\n   * host:string will neeed to be passed for virtual hosts in RabbitMQ\n   */\n  headers: StompHeaders;\n\n  /** How often to incoming heartbeat?\n   * Interval in milliseconds, set to 0 to disable\n   *\n   * Typical value 0 - disabled\n   */\n  heartbeat_in: number;\n\n  /**\n   * How often to outgoing heartbeat?\n   * Interval in milliseconds, set to 0 to disable\n   *\n   * Typical value 20000 - every 20 seconds\n   */\n  heartbeat_out: number;\n\n  /**\n   * Wait in milliseconds before attempting auto reconnect\n   * Set to 0 to disable\n   *\n   * Typical value 5000 (5 seconds)\n   */\n  reconnect_delay: number;\n\n  /** Enable client debugging? */\n  debug: boolean;\n}\n","import { Injectable } from '@angular/core';\n\nimport { StompConfig } from './stomp.config';\n\nimport { StompRService } from './stomp-r.service';\n\n/**\n * Angular2 STOMP Service using @stomp/stomp.js\n *\n * @description This service handles subscribing to a\n * message queue using the stomp.js library, and returns\n * values via the ES6 Observable specification for\n * asynchronous value streaming by wiring the STOMP\n * messages into an observable.\n *\n * If you want to manually configure and initialize the service\n * please use StompRService\n */\n@Injectable()\nexport class StompService extends StompRService {\n\n  /**\n   * Constructor\n   *\n   * See README and samples for configuration examples\n   */\n  public constructor(config: StompConfig) {\n    super();\n\n    this.config = config;\n    this.initAndConnect();\n  }\n}\n","import {Injectable} from '@angular/core';\n\nimport {RxStompRPC} from \"@stomp/rx-stomp\";\n\n/**\n * An implementation of RPC service using messaging.\n *\n * Please see the [guide](../additional-documentation/rpc---remote-procedure-call.html) for details.\n */\n@Injectable()\nexport class StompRPCService extends RxStompRPC { }\n","import {Injectable} from \"@angular/core\";\n\nimport {RxStompRPCConfig} from \"@stomp/rx-stomp\";\n\n/**\n * RPC Config. See the guide for example.\n */\n@Injectable()\nexport class StompRPCConfig extends RxStompRPCConfig { }\n"],"names":[],"mappings":"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"}
