{"version":3,"file":"stomp-ng2-stompjs.js.map","sources":["ng://@stomp/ng2-stompjs/src/stomp-r.service.ts","ng://@stomp/ng2-stompjs/src/stomp.config.ts","ng://@stomp/ng2-stompjs/src/stomp.service.ts","ng://@stomp/ng2-stompjs/src/stomp-rpc.service.ts"],"sourcesContent":["import { first, filter, share } from 'rxjs/operators';\nimport { Injectable } from '@angular/core';\nimport { BehaviorSubject ,  Observable ,  Observer ,  Subject ,  Subscription } from 'rxjs';\n\nimport { StompConfig } from './stomp.config';\n\nimport * as Stomp from '@stomp/stompjs';\nimport { Frame, StompSubscription } from '@stomp/stompjs';\nimport { StompHeaders } from './stomp-headers';\nimport { StompState } from './stomp-state';\n\n/**\n * Angular2 STOMP Raw Service using @stomp/stomp.js\n *\n * You will only need the public properties and\n * methods listed unless you are an advanced user. This service handles subscribing to a\n * message queue using the stomp.js library, and returns\n * values via the ES6 Observable specification for\n * asynchronous value streaming by wiring the STOMP\n * messages into an observable.\n *\n * If you will like to pass the configuration as a dependency,\n * please use StompService class.\n */\n@Injectable()\nexport class StompRService {\n  /**\n   * State of the STOMPService\n   *\n   * It is a BehaviorSubject and will emit current status immediately. This will typically get\n   * used to show current status to the end user.\n   */\n  public state: BehaviorSubject<StompState>;\n\n  /**\n   * Will trigger when connection is established. Use this to carry out initialization.\n   * It will trigger every time a (re)connection occurs. If it is already connected\n   * it will trigger immediately. You can safely ignore the value, as it will always be\n   * StompState.CONNECTED\n   */\n  public connectObservable: Observable<StompState>;\n\n  /**\n   * Provides headers from most recent connection to the server as return by the CONNECTED\n   * frame.\n   * If the STOMP connection has already been established it will trigger immediately.\n   * It will additionally trigger in event of reconnection, the value will be set of headers from\n   * the recent server response.\n   */\n  public serverHeadersObservable: Observable<StompHeaders>;\n\n  private _serverHeadersBehaviourSubject: BehaviorSubject<null | StompHeaders>;\n\n  /**\n   * Will emit all messages to the default queue (any message that are not handled by a subscription)\n   */\n  public defaultMessagesObservable: Subject<Stomp.Message>;\n\n  /**\n   * Will emit all receipts\n   */\n  public receiptsObservable: Subject<Stomp.Frame>;\n\n  /**\n   * Will trigger when an error occurs. This Subject can be used to handle errors from\n   * the stomp broker.\n   */\n  public errorSubject: Subject<string | Stomp.Message>;\n\n  /**\n   * Internal array to hold locally queued messages when STOMP broker is not connected.\n   */\n  protected queuedMessages: { queueName: string, message: string, headers: StompHeaders }[] = [];\n\n  /**\n   * Configuration\n   */\n  private _config: StompConfig;\n\n  /**\n   * STOMP Client from @stomp/stomp.js\n   */\n  protected client: Stomp.Client;\n\n  /**\n   * Constructor\n   *\n   * See README and samples for configuration examples\n   */\n  public constructor() {\n    this.state = new BehaviorSubject<StompState>(StompState.CLOSED);\n\n    this.connectObservable = this.state.pipe(\n      filter((currentState: StompState) => {\n        return currentState === StompState.CONNECTED;\n      })\n    );\n\n    // Setup sending queuedMessages\n    this.connectObservable.subscribe(() => {\n      this.sendQueuedMessages();\n    });\n\n    this._serverHeadersBehaviourSubject = new BehaviorSubject<null | StompHeaders>(null);\n\n    this.serverHeadersObservable = this._serverHeadersBehaviourSubject.pipe(\n      filter((headers: null | StompHeaders) => {\n        return headers !== null;\n      })\n    );\n\n    this.errorSubject = new Subject();\n  }\n\n  /** Set configuration */\n  set config(value: StompConfig) {\n    this._config = value;\n  }\n\n  /** It will initialize STOMP Client. */\n  protected initStompClient(): void {\n    // disconnect if connected\n    this.disconnect();\n\n    // url takes precedence over socketFn\n    if (typeof(this._config.url) === 'string') {\n      this.client = Stomp.client(this._config.url);\n    } else {\n      this.client = Stomp.over(this._config.url);\n    }\n\n    // Configure client heart-beating\n    this.client.heartbeat.incoming = this._config.heartbeat_in;\n    this.client.heartbeat.outgoing = this._config.heartbeat_out;\n\n    // Auto reconnect\n    this.client.reconnect_delay = this._config.reconnect_delay;\n\n    if (!this._config.debug) {\n      this.debug = function () {\n      };\n    }\n    // Set function to debug print messages\n    this.client.debug = this.debug;\n\n    // Default messages\n    this.setupOnReceive();\n\n    // Receipts\n    this.setupReceipts();\n  }\n\n\n  /**\n   * It will connect to the STOMP broker.\n   */\n  public initAndConnect(): void {\n    this.initStompClient();\n\n    if (!this._config.headers) {\n      this._config.headers = {};\n    }\n\n    // Attempt connection, passing in a callback\n    this.client.connect(\n      this._config.headers,\n      this.on_connect,\n      this.on_error\n    );\n\n    this.debug('Connecting...');\n    this.state.next(StompState.TRYING);\n  }\n\n\n  /**\n   * It will disconnect from the STOMP broker.\n   */\n  public disconnect(): void {\n\n    // Disconnect if connected. Callback will set CLOSED state\n    if (this.client) {\n      if (!this.client.connected) {\n        // Nothing to do\n        this.state.next(StompState.CLOSED);\n        return;\n      }\n\n      // Notify observers that we are disconnecting!\n      this.state.next(StompState.DISCONNECTING);\n\n      this.client.disconnect(\n        () => this.state.next(StompState.CLOSED)\n      );\n    }\n  }\n\n  /**\n   * It will return `true` if STOMP broker is connected and `false` otherwise.\n   */\n  public connected(): boolean {\n    return this.state.getValue() === StompState.CONNECTED;\n  }\n\n  /**\n   * It will send a message to a named destination. The message must be `string`.\n   *\n   * The message will get locally queued if the STOMP broker is not connected. It will attempt to\n   * publish queued messages as soon as the broker gets connected.\n   *\n   * @param queueName\n   * @param message\n   * @param headers\n   */\n  public publish(queueName: string, message: string, headers: StompHeaders = {}): void {\n    if (this.connected()) {\n      this.client.send(queueName, headers, message);\n    } else {\n      this.debug(`Not connected, queueing ${message}`);\n      this.queuedMessages.push({queueName: <string>queueName, message: <string>message, headers: headers});\n    }\n  }\n\n  /** It will send queued messages. */\n  protected sendQueuedMessages(): void {\n    const queuedMessages = this.queuedMessages;\n    this.queuedMessages = [];\n\n    this.debug(`Will try sending queued messages ${queuedMessages}`);\n\n    for (const queuedMessage of queuedMessages) {\n      this.debug(`Attempting to send ${queuedMessage}`);\n      this.publish(queuedMessage.queueName, queuedMessage.message, queuedMessage.headers);\n    }\n  }\n\n  /**\n   * It will subscribe to server message queues\n   *\n   * This method can be safely called even if the STOMP broker is not connected.\n   * If the underlying STOMP connection drops and reconnects, it will resubscribe automatically.\n   *\n   * If a header field 'ack' is not explicitly passed, 'ack' will be set to 'auto'. If you\n   * do not understand what it means, please leave it as is.\n   *\n   * Note that when working with temporary queues where the subscription request\n   * creates the\n   * underlying queue, mssages might be missed during reconnect. This issue is not specific\n   * to this library but the way STOMP brokers are designed to work.\n   *\n   * @param queueName\n   * @param headers\n   */\n  public subscribe(queueName: string, headers: StompHeaders = {}): Observable<Stomp.Message> {\n\n    /* Well the logic is complicated but works beautifully. RxJS is indeed wonderful.\n     *\n     * We need to activate the underlying subscription immediately if Stomp is connected. If not it should\n     * subscribe when it gets next connected. Further it should re establish the subscription whenever Stomp\n     * successfully reconnects.\n     *\n     * Actual implementation is simple, we filter the BehaviourSubject 'state' so that we can trigger whenever Stomp is\n     * connected. Since 'state' is a BehaviourSubject, if Stomp is already connected, it will immediately trigger.\n     *\n     * The observable that we return to caller remains same across all reconnects, so no special handling needed at\n     * the message subscriber.\n     */\n    this.debug(`Request to subscribe ${queueName}`);\n\n    // By default auto acknowledgement of messages\n    if (!headers['ack']) {\n      headers['ack'] = 'auto';\n    }\n\n    const coldObservable = Observable.create(\n      (messages: Observer<Stomp.Message>) => {\n        /*\n         * These variables will be used as part of the closure and work their magic during unsubscribe\n         */\n        let stompSubscription: StompSubscription;\n\n        let stompConnectedSubscription: Subscription;\n\n        stompConnectedSubscription = this.connectObservable\n          .subscribe(() => {\n            this.debug(`Will subscribe to ${queueName}`);\n            stompSubscription = this.client.subscribe(queueName, (message: Stomp.Message) => {\n                messages.next(message);\n              },\n              headers);\n          });\n\n        return () => { /* cleanup function, will be called when no subscribers are left */\n          this.debug(`Stop watching connection state (for ${queueName})`);\n          stompConnectedSubscription.unsubscribe();\n\n          if (this.state.getValue() === StompState.CONNECTED) {\n            this.debug(`Will unsubscribe from ${queueName} at Stomp`);\n            stompSubscription.unsubscribe();\n          } else {\n            this.debug(`Stomp not connected, no need to unsubscribe from ${queueName} at Stomp`);\n          }\n        };\n      });\n\n    /**\n     * Important - convert it to hot Observable - otherwise, if the user code subscribes\n     * to this observable twice, it will subscribe twice to Stomp broker. (This was happening in the current example).\n     * A long but good explanatory article at https://medium.com/@benlesh/hot-vs-cold-observables-f8094ed53339\n     */\n    return coldObservable.pipe(share());\n  }\n\n  /**\n   * It will handle messages received in the default queue. Messages that would not be handled otherwise\n   * get delivered to the default queue.\n   */\n  protected setupOnReceive(): void {\n    this.defaultMessagesObservable = new Subject();\n\n    this.client.onreceive = (message: Stomp.Message) => {\n      this.defaultMessagesObservable.next(message);\n    };\n  }\n\n  /**\n   * It will emit all receipts.\n   */\n  protected setupReceipts(): void {\n    this.receiptsObservable = new Subject();\n\n    this.client.onreceipt = (frame: Stomp.Frame) => {\n      this.receiptsObservable.next(frame);\n    };\n  }\n\n  /**\n   * Wait for receipt, this indicates that server has carried out the related operation\n   */\n  public waitForReceipt(receiptId: string, callback: (frame: Stomp.Frame) => void): void {\n    this.receiptsObservable.pipe(\n      filter((frame: Stomp.Frame) => {\n        return frame.headers['receipt-id'] === receiptId;\n      }),\n      first()\n    ).subscribe((frame: Stomp.Frame) => {\n      callback(frame);\n    });\n  }\n\n  /**\n   * Callback Functions\n   *\n   * Note the method signature: () => preserves lexical scope\n   * if we need to use this.x inside the function\n   */\n  protected debug = (args: any): void => {\n    console.log(new Date(), args);\n  }\n\n  /** Callback run on successfully connecting to server */\n  protected on_connect = (frame: Frame) => {\n\n    this.debug('Connected');\n\n    this._serverHeadersBehaviourSubject.next(frame.headers);\n\n    // Indicate our connected state to observers\n    this.state.next(StompState.CONNECTED);\n  }\n\n  /** Handle errors from stomp.js */\n  protected on_error = (error: string | Stomp.Message) => {\n\n    // Trigger the error subject\n    this.errorSubject.next(error);\n\n    if (typeof error === 'object') {\n      error = (<Stomp.Message>error).body;\n    }\n\n    this.debug(`Error: ${error}`);\n\n    // Check for dropped connection and try reconnecting\n    if (!this.client.connected) {\n      // Reset state indicator\n      this.state.next(StompState.CLOSED);\n    }\n  }\n}\n","import { StompHeaders } from './stomp-headers';\nimport { Injectable } from '@angular/core';\n/**\n * Represents a configuration object for the\n * STOMPService to connect to.\n */\n\n@Injectable()\nexport class StompConfig {\n  /**\n   * Server URL to connect to. Please refer to your STOMP broker documentation for details.\n   *\n   * Example: ws://127.0.0.1:15674/ws (for a RabbitMQ default setup running on localhost)\n   *\n   * Alternatively this parameter can be a function that returns an object similar to WebSocket\n   * (typically SockJS instance).\n   *\n   * Example:\n   *\n   * () => {\n   *   return new SockJS('http://127.0.0.1:15674/stomp');\n   * }\n   */\n  url: string | (() => any);\n\n  /**\n   * Headers\n   * Typical keys: login: string, passcode: string.\n   * host:string will neeed to be passed for virtual hosts in RabbitMQ\n   */\n  headers: StompHeaders;\n\n  /** How often to incoming heartbeat?\n   * Interval in milliseconds, set to 0 to disable\n   *\n   * Typical value 0 - disabled\n   */\n  heartbeat_in: number;\n\n  /**\n   * How often to outgoing heartbeat?\n   * Interval in milliseconds, set to 0 to disable\n   *\n   * Typical value 20000 - every 20 seconds\n   */\n  heartbeat_out: number;\n\n  /**\n   * Wait in milliseconds before attempting auto reconnect\n   * Set to 0 to disable\n   *\n   * Typical value 5000 (5 seconds)\n   */\n  reconnect_delay: number;\n\n  /** Enable client debugging? */\n  debug: boolean;\n}\n","import { Injectable } from '@angular/core';\n\nimport { StompConfig } from './stomp.config';\n\nimport { StompRService } from './stomp-r.service';\n\n/**\n * Angular2 STOMP Service using @stomp/stomp.js\n *\n * @description This service handles subscribing to a\n * message queue using the stomp.js library, and returns\n * values via the ES6 Observable specification for\n * asynchronous value streaming by wiring the STOMP\n * messages into an observable.\n *\n * If you want to manually configure and initialize the service\n * please use StompRService\n */\n@Injectable()\nexport class StompService extends StompRService {\n\n  /**\n   * Constructor\n   *\n   * See README and samples for configuration examples\n   */\n  public constructor(config: StompConfig) {\n    super();\n\n    this.config = config;\n    this.initAndConnect();\n  }\n}\n","import { Injectable } from '@angular/core';\nimport { StompService } from './stomp.service';\nimport { Message } from '@stomp/stompjs';\nimport { UUID } from 'angular2-uuid';\nimport { Observable, Observer, Subject, Subscription } from \"rxjs\";\nimport { filter, first } from \"rxjs/operators\";\n\n@Injectable()\nexport class StompRPCService {\n  protected replyQueue = 'rpc-replies';\n\n  protected messagesObservable: Subject<Message>;\n\n  constructor(private stompService: StompService) {\n    this.messagesObservable = this.stompService.defaultMessagesObservable;\n  }\n\n  public rpc(serviceEndPoint: string, payload: string): Observable<Message> {\n    // We know there will be only one message in reply\n    return this.stream(serviceEndPoint, payload).pipe(first());\n  }\n\n  private stream(serviceEndPoint: string, payload: string) {\n    return Observable.create(\n      (rpcObserver: Observer<Message>) => {\n        let defaultMessagesSubscription: Subscription;\n\n        const correlationId = UUID.UUID();\n\n        defaultMessagesSubscription = this.messagesObservable.pipe(filter((message: Message) => {\n          return message.headers['correlation-id'] === correlationId;\n        })).subscribe((message: Message) => {\n          rpcObserver.next(message);\n        });\n\n        // send an RPC request\n        const headers = {\n          'reply-to': `/temp-queue/${this.replyQueue}`,\n          'correlation-id': correlationId\n        };\n\n        this.stompService.publish(serviceEndPoint, payload, headers);\n\n        return () => { // Cleanup\n          defaultMessagesSubscription.unsubscribe();\n        };\n      }\n    );\n  }\n}\n"],"names":["Stomp.client","Stomp.over","tslib_1.__values","tslib_1.__extends"],"mappings":"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"}
