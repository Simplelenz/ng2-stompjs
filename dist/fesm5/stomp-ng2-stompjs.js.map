{"version":3,"file":"stomp-ng2-stompjs.js.map","sources":["ng://@stomp/ng2-stompjs/src/stomp-r.service.ts","ng://@stomp/ng2-stompjs/src/stomp.config.ts","ng://@stomp/ng2-stompjs/src/stomp.service.ts","ng://@stomp/ng2-stompjs/src/stomp-rpc.service.ts","ng://@stomp/ng2-stompjs/src/stomp-rpc.config.ts"],"sourcesContent":["import {Injectable} from '@angular/core';\n\nimport {RxStomp, RxStompConfig, RxStompState} from \"@stomp/rx-stomp\";\n\nimport {publishParams, Client, Message, Frame} from \"@stomp/stompjs\";\n\nimport {BehaviorSubject, Observable, Subject} from \"rxjs\";\nimport {map} from \"rxjs/operators\";\n\nimport {StompState} from \"./stomp-state\";\nimport { StompHeaders } from './stomp-headers';\nimport {StompConfig} from \"./stomp.config\";\n\n/**\n * Angular2 STOMP Raw Service using @stomp/stomp.js\n *\n * You will only need the public properties and\n * methods listed unless you are an advanced user. This service handles subscribing to a\n * message queue using the stomp.js library, and returns\n * values via the ES6 Observable specification for\n * asynchronous value streaming by wiring the STOMP\n * messages into an observable.\n *\n * If you will like to pass the configuration as a dependency,\n * please use StompService class.\n */\n@Injectable()\nexport class StompRService extends RxStomp {\n  /**\n   * State of the STOMPService\n   *\n   * It is a BehaviorSubject and will emit current status immediately. This will typically get\n   * used to show current status to the end user.\n   */\n  public state: BehaviorSubject<StompState>;\n\n  private static _mapStompState(st: RxStompState): StompState {\n    if (st === RxStompState.CONNECTING) {\n      return StompState.TRYING;\n    }\n    if (st === RxStompState.OPEN) {\n      return StompState.CONNECTED;\n    }\n    if (st === RxStompState.CLOSING) {\n      return StompState.DISCONNECTING;\n    }\n    if (st === RxStompState.CLOSED) {\n      return StompState.CLOSED;\n    }\n  }\n\n  /**\n   * Will trigger when connection is established. Use this to carry out initialization.\n   * It will trigger every time a (re)connection occurs. If it is already connected\n   * it will trigger immediately. You can safely ignore the value, as it will always be\n   * StompState.CONNECTED\n   */\n  get connectObservable(): Observable<StompState> {\n    return this.connected$.pipe(map((st: RxStompState): StompState => {\n      return StompRService._mapStompState(st);\n    }));\n  }\n\n  /**\n   * Provides headers from most recent connection to the server as return by the CONNECTED\n   * frame.\n   * If the STOMP connection has already been established it will trigger immediately.\n   * It will additionally trigger in event of reconnection, the value will be set of headers from\n   * the recent server response.\n   */\n  get serverHeadersObservable(): Observable<StompHeaders> {\n    return this.serverHeaders$;\n  }\n\n  /**\n   * Will emit all messages to the default queue (any message that are not handled by a subscription)\n   */\n  get defaultMessagesObservable(): Subject<Message> {\n    return this.unhandledMessage$;\n  }\n\n  /**\n   * Will emit all receipts\n   */\n  get receiptsObservable(): Subject<Frame> {\n    return this.unhandledReceipts$;\n  }\n\n  /**\n   * Will trigger when an error occurs. This Subject can be used to handle errors from\n   * the stomp broker.\n   */\n  get errorSubject(): Subject<string | Frame> {\n    return this.stompErrors$;\n  }\n\n  /** Set configuration */\n  set config(config: StompConfig) {\n    const rxStompConfig: RxStompConfig = { };\n\n    if (typeof(config.url) === 'string') {\n      rxStompConfig.brokerURL = config.url;\n    } else {\n      rxStompConfig.webSocketFactory = config.url;\n    }\n\n    // Configure client heart-beating\n    rxStompConfig.heartbeatIncoming = config.heartbeat_in;\n    rxStompConfig.heartbeatOutgoing = config.heartbeat_out;\n\n    // Auto reconnect\n    rxStompConfig.reconnectDelay = config.reconnect_delay;\n\n    if (config.debug) {\n      rxStompConfig.debug = (str: string): void => {\n        console.log(new Date(), str);\n      }\n    }\n\n    rxStompConfig.connectHeaders = config.headers;\n\n    this.configure(rxStompConfig);\n  }\n  /**\n   * It will connect to the STOMP broker.\n   */\n  public initAndConnect(): void {\n    // disconnect if connected\n    this.deactivate();\n\n    // Attempt connection, passing in a callback\n    this.activate();\n  }\n\n  /**\n   * It will disconnect from the STOMP broker.\n   */\n  public disconnect(): void {\n    this.deactivate();\n  }\n\n  /**\n   * It will send a message to a named destination. The message must be `string`.\n   *\n   * The message will get locally queued if the STOMP broker is not connected. It will attempt to\n   * publish queued messages as soon as the broker gets connected.\n   *\n   * @param queueName\n   * @param message\n   * @param headers\n   */\n  public publish(queueName: string|publishParams, message?: string, headers: StompHeaders = {}): void {\n    if (typeof queueName === 'string') {\n      super.publish({destination: queueName as string, body: message, headers});\n    } else {\n      const pubParams: publishParams = queueName;\n      super.publish(pubParams);\n    }\n  }\n\n  /**\n   * It will subscribe to server message queues\n   *\n   * This method can be safely called even if the STOMP broker is not connected.\n   * If the underlying STOMP connection drops and reconnects, it will resubscribe automatically.\n   *\n   * If a header field 'ack' is not explicitly passed, 'ack' will be set to 'auto'. If you\n   * do not understand what it means, please leave it as is.\n   *\n   * Note that when working with temporary queues where the subscription request\n   * creates the\n   * underlying queue, mssages might be missed during reconnect. This issue is not specific\n   * to this library but the way STOMP brokers are designed to work.\n   *\n   * @param queueName\n   * @param headers\n   */\n  public subscribe(queueName: string, headers: StompHeaders = {}): Observable<Message> {\n    return this.watch(queueName, headers);\n  }\n\n  get client(): Client {\n    return this._stompClient;\n  }\n\n  public constructor() {\n    super();\n\n    this.state = new BehaviorSubject<StompState>(StompState.CLOSED);\n\n    this.connectionState$.subscribe((st: RxStompState) => {\n      this.state.next(StompRService._mapStompState(st));\n    });\n  }\n}\n","import { Injectable } from '@angular/core';\nimport { StompHeaders } from \"@stomp/stompjs\";\n/**\n * Represents a configuration object for the\n * STOMPService to connect to.\n */\n\n@Injectable()\nexport class StompConfig {\n  /**\n   * Server URL to connect to. Please refer to your STOMP broker documentation for details.\n   *\n   * Example: ws://127.0.0.1:15674/ws (for a RabbitMQ default setup running on localhost)\n   *\n   * Alternatively this parameter can be a function that returns an object similar to WebSocket\n   * (typically SockJS instance).\n   *\n   * Example:\n   *\n   * () => {\n   *   return new SockJS('http://127.0.0.1:15674/stomp');\n   * }\n   */\n  url: string | (() => any);\n\n  /**\n   * Headers\n   * Typical keys: login: string, passcode: string.\n   * host:string will neeed to be passed for virtual hosts in RabbitMQ\n   */\n  headers: StompHeaders;\n\n  /** How often to incoming heartbeat?\n   * Interval in milliseconds, set to 0 to disable\n   *\n   * Typical value 0 - disabled\n   */\n  heartbeat_in: number;\n\n  /**\n   * How often to outgoing heartbeat?\n   * Interval in milliseconds, set to 0 to disable\n   *\n   * Typical value 20000 - every 20 seconds\n   */\n  heartbeat_out: number;\n\n  /**\n   * Wait in milliseconds before attempting auto reconnect\n   * Set to 0 to disable\n   *\n   * Typical value 5000 (5 seconds)\n   */\n  reconnect_delay: number;\n\n  /** Enable client debugging? */\n  debug: boolean;\n}\n","import { Injectable } from '@angular/core';\n\nimport { StompConfig } from './stomp.config';\n\nimport { StompRService } from './stomp-r.service';\n\n/**\n * Angular2 STOMP Service using @stomp/stomp.js\n *\n * @description This service handles subscribing to a\n * message queue using the stomp.js library, and returns\n * values via the ES6 Observable specification for\n * asynchronous value streaming by wiring the STOMP\n * messages into an observable.\n *\n * If you want to manually configure and initialize the service\n * please use StompRService\n */\n@Injectable()\nexport class StompService extends StompRService {\n\n  /**\n   * Constructor\n   *\n   * See README and samples for configuration examples\n   */\n  public constructor(config: StompConfig) {\n    super();\n\n    this.config = config;\n    this.initAndConnect();\n  }\n}\n","import {Injectable} from '@angular/core';\n\nimport {RxStompRPC} from \"@stomp/rx-stomp\";\n\n/**\n * An implementation of RPC service using messaging.\n *\n * Please see the [guide](../additional-documentation/rpc---remote-procedure-call.html) for details.\n */\n@Injectable()\nexport class StompRPCService extends RxStompRPC { }\n","import {Injectable} from \"@angular/core\";\n\nimport {RxStompRPCConfig} from \"@stomp/rx-stomp\";\n\n/**\n * RPC Config. See the guide for example.\n */\n@Injectable()\nexport class StompRPCConfig extends RxStompRPCConfig { }\n"],"names":["tslib_1.__extends"],"mappings":"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"}
